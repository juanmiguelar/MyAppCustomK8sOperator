# Building a Kubernetes Operator with KubeBuilder on Mac M1

A hands-on tutorial for Go developers who understand microservices but are new to Kubernetes operators. We'll build an operator that manages a custom `MyApp` resource — when you create one, the operator automatically creates a `Deployment`. Same pattern Tekton uses for `Pipeline` and `Task`.

---

## Prerequisites

You need `kubectl` installed. Then grab these three things:

### 1. Local cluster — Colima
```bash
brew install colima
colima start --kubernetes
kubectl get nodes  # should show one Ready node
```

### 2. Go
```bash
brew install go
go version  # need 1.21+
```

> **Gotcha:** If you already had Go installed and recently upgraded via Homebrew, your shell might still point to the old version. Fix it permanently:
> ```bash
> export GOROOT=/opt/homebrew/Cellar/go/1.26.0/libexec
> export PATH=$GOROOT/bin:$PATH
> echo 'export GOROOT=/opt/homebrew/Cellar/go/1.26.0/libexec' >> ~/.zshrc
> echo 'export PATH=$GOROOT/bin:$PATH' >> ~/.zshrc
> ```
> Verify: `go version` and `go env GOROOT` should both show 1.26.0.

### 3. KubeBuilder
```bash
# Note: don't use $() subshells in zsh for this — use the hardcoded URL
curl -L -o kubebuilder "https://go.kubebuilder.io/dl/latest/darwin/arm64"
chmod +x kubebuilder
sudo mv kubebuilder /usr/local/bin/
kubebuilder version  # should show v4.x
```

---

## Step 1 — Scaffold the project

```bash
mkdir myapp-operator && cd myapp-operator
go mod init github.com/yourusername/myapp-operator

kubebuilder init --domain example.com
kubebuilder create api --group apps --version v1 --kind MyApp
# Answer: y, y
```

This generates the full structure:
```
myapp-operator/
├── api/v1/
│   └── myapp_types.go       # your CRD definition lives here
├── internal/controller/
│   └── myapp_controller.go  # your reconciler lives here
├── config/                  # yamls to deploy to the cluster
└── main.go
```

---

## Step 2 — Define your CRD

Replace `api/v1/myapp_types.go` with this clean version. The scaffold generates some markers (`+listType`, `+listMapKey`) that only apply to arrays — they'll break the build if you leave them on non-array fields:

```go
package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// MyAppSpec defines the desired state of MyApp
type MyAppSpec struct {
	// +kubebuilder:validation:Minimum=1
	Replicas int32  `json:"replicas,omitempty"`
	Image    string `json:"image"`
}

// MyAppStatus defines the observed state of MyApp.
type MyAppStatus struct {
	// +optional
	ReadyReplicas int32 `json:"readyReplicas,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

type MyApp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MyAppSpec   `json:"spec,omitempty"`
	Status            MyAppStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

type MyAppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MyApp `json:"items"`
}

func init() {
	SchemeBuilder.Register(&MyApp{}, &MyAppList{})
}
```

`Spec` = desired state (you define it)  
`Status` = current state (the operator writes it)

After editing, regenerate the deep copy functions:
```bash
make generate
```

> This regenerates `zz_generated.deepcopy.go` — never edit that file manually, it's always autogenerated from your types.

---

## Step 3 — The Reconciler

Replace `internal/controller/myapp_controller.go` completely:

```go
package controller

import (
	"context"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	logf "sigs.k8s.io/controller-runtime/pkg/log"

	myappsv1 "github.com/juanmiguelar/myapp-operator/api/v1"
)

type MyAppReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=apps.example.com,resources=myapps,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=apps.example.com,resources=myapps/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// Note: the RBAC marker for deployments is critical — without it the operator
// silently fails to create Deployments even though the code looks correct.

func (r *MyAppReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := logf.FromContext(ctx) // use := not = — the scaffold generates a bug here

	// 1. Fetch the MyApp that triggered this reconcile
	myApp := &myappsv1.MyApp{}
	if err := r.Get(ctx, req.NamespacedName, myApp); err != nil {
		if errors.IsNotFound(err) {
			return ctrl.Result{}, nil // deleted, nothing to do
		}
		return ctrl.Result{}, err
	}

	// 2. Define the desired Deployment
	deploy := &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:      myApp.Name,
			Namespace: myApp.Namespace,
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: &myApp.Spec.Replicas,
			Selector: &metav1.LabelSelector{
				MatchLabels: map[string]string{"app": myApp.Name},
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{"app": myApp.Name},
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{{
						Name:  myApp.Name,
						Image: myApp.Spec.Image,
					}},
				},
			},
		},
	}

	// 3. Ownership — if MyApp is deleted, the Deployment gets garbage collected too
	if err := controllerutil.SetControllerReference(myApp, deploy, r.Scheme); err != nil {
		return ctrl.Result{}, err
	}

	// 4. Create or skip — idempotent
	existing := &appsv1.Deployment{}
	err := r.Get(ctx, types.NamespacedName{Name: deploy.Name, Namespace: deploy.Namespace}, existing)
	if errors.IsNotFound(err) {
		log.Info("Creating Deployment", "name", deploy.Name)
		return ctrl.Result{}, r.Create(ctx, deploy)
	}
	if err != nil {
		return ctrl.Result{}, err
	}

	// 5. Sync status from actual Deployment state
	myApp.Status.ReadyReplicas = existing.Status.ReadyReplicas
	if err := r.Status().Update(ctx, myApp); err != nil {
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: time.Minute}, nil
}

func (r *MyAppReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&myappsv1.MyApp{}).
		Named("myapp").
		Complete(r)
}
```

---

## Step 4 — Install CRDs and run the operator

```bash
# Install the CRDs into the cluster
make install
# Expected output: customresourcedefinition.apiextensions.k8s.io/myapps.apps.example.com created

# Verify
kubectl get crds | grep myapps
```

In a **separate terminal**, start the operator:
```bash
make run
```

> The operator runs locally but talks to your Colima cluster via kubeconfig. This is the standard dev workflow — you don't need to build a container image to iterate.

---

## Step 5 — Create your first custom resource

```yaml
# myapp-sample.yaml
apiVersion: apps.example.com/v1
kind: MyApp        # capital M and A — case sensitive, will fail silently otherwise
metadata:
  name: my-first-app
spec:
  replicas: 2
  image: nginx:1.27.4  # never use latest in practice
```

```bash
kubectl apply -f myapp-sample.yaml

# The operator detects it and creates the Deployment automatically
kubectl get myapps
kubectl get deployments  # my-first-app should appear with 2 replicas
```

---

## What just happened

```
kubectl apply (MyApp)
    → API Server stores it in etcd
    → Controller Watch detects the event
    → Reconcile() runs
    → Deployment created
    → Status updated
    → RequeueAfter: 1 minute (runs again to sync status)
```

This is exactly the same flow Tekton uses when you `kubectl apply -f pipeline.yaml`. The difference is that at Windriver you were consuming this pattern — here you built it.

---

## Known gotchas (learned the hard way)

| Issue | Cause | Fix |
|---|---|---|
| `zsh: parse error near ')'` | zsh doesn't like `$()` inside curl args | Use hardcoded `darwin/arm64` URL |
| `cannot find GOROOT directory` | Shell still pointing to old Go after brew upgrade | Set `GOROOT` and `PATH` explicitly |
| `go tool version mismatch` | `go.mod` references old Go version | `go mod edit -go=1.26.0 && go mod tidy` |
| `must apply listType to an array` | Scaffold markers left on non-array fields | Remove `+listType` and `+listMapKey` from `MyAppStatus` |
| `no matches for kind "myApp"` | Wrong casing in yaml | `kind: MyApp` not `myApp` |
| Deployment never created | Missing RBAC marker for `apps/deployments` | Add the `+kubebuilder:rbac` comment for deployments |
